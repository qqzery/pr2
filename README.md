day 1
//
pr2
123

//code
public class Main {
public static void main(String[] args) {
System.out.println("Група: 34");
System.out.println("Вчитель: Олійник");
System.out.println("Аргументи командного рядка:");
for (String arg : args) {
System.out.println(arg);
}
}
}

day 2
//
pr2
123

import java.io.Serializable;
import java.io.*;

class ДаніОбчислення implements Serializable {
    private final double параметр1;
    private final double параметр2;
    private transient double результат;

    ДаніОбчислення(double парам1, double парам2) {
        this.параметр1 = парам1;
        this.параметр2 = парам2;
        this.результат = 0.0;
    }

    void обчислитиРезультат() {
        this.результат = параметр1 + параметр2;
    }

    double отриматиПараметр1() {
        return параметр1;
    }

    double отриматиПараметр2() {
        return параметр2;
    }

    double отриматиРезультат() {
        return результат;
    }
}

class Калькулятор {
    private final ДаніОбчислення дані;

    Калькулятор(double парам1, double парам2) {
        this.дані = new ДаніОбчислення(парам1, парам2);
        this.дані.обчислитиРезультат();
    }

    double отриматиРезультат() {
        return дані.отриматиРезультат();
    }

    ДаніОбчислення отриматиДані() {
        return дані;
    }
}

class ДемонстраціяСеріалізації {
    static void зберегтиОбєкт(ДаніОбчислення дані, String імʼяФайлу) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(імʼяФайлу))) {
            out.writeObject(дані);
            System.out.println("Обʼєкт успішно збережено");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static ДаніОбчислення завантажитиОбєкт(String імʼяФайлу) {
        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(імʼяФайлу))) {
            ДаніОбчислення дані = (ДаніОбчислення) in.readObject();
            System.out.println("Обʼєкт успішно завантажено");
            return дані;
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
}

class ТестОбчислень {
    static void тестуватиОбчислення() {
        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        double очікуваний = 8.0;
        double фактичний = калькулятор.отриматиРезультат();
        
        if (Math.abs(очікуваний - фактичний) < 0.0001) {
            System.out.println("Тест обчислень пройдено");
        } else {
            System.out.println("Тест обчислень не пройдено: очікувалось " + очікуваний + ", отримано " + фактичний);
        }
    }

    static void тестуватиСеріалізацію() {
        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        ДемонстраціяСеріалізації.зберегтиОбєкт(калькулятор.отриматиДані(), "тест.ser");
        
        ДаніОбчислення завантажені = ДемонстраціяСеріалізації.завантажитиОбєкт("тест.ser");
        if (завантажені != null && 
            Math.abs(завантажені.отриматиПараметр1() - 5.0) < 0.0001 && 
            Math.abs(завантажені.отриматиПараметр2() - 3.0) < 0.0001) {
            System.out.println("Тест серіалізації пройдено");
        } else {
            System.out.println("Тест серіалізації не пройдено");
        }
        
        if (завантажені != null && завантажені.отриматиРезультат() == 0.0) {
            System.out.println("Тест поля transient пройдено");
        } else {
            System.out.println("Тест поля transient не пройдено");
        }
    }
}

public class Main {
    static int порахуватиЧергування(int число) {
        String двійковеПодання = Integer.toBinaryString(число);
        int кількістьЧергувань = 0;
        
        for (int i = 1; i < двійковеПодання.length(); i++) {
            if (двійковеПодання.charAt(i) != двійковеПодання.charAt(i - 1)) {
                кількістьЧергувань++;
            }
        }
        return кількістьЧергувань;
    }

    public static void main(String[] args) {
        System.out.println("Группа: 34");
        System.out.println("Учитель: Олейник");
        System.out.println("Аргументы командной строки:");
        for (String arg : args) {
            System.out.println(arg);
        }

        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        System.out.println("Результат расчета: " + калькулятор.отриматиРезультат());

        ДемонстраціяСеріалізації.зберегтиОбєкт(калькулятор.отриматиДані(), "дані_обчислення.ser");
        
        ДаніОбчислення завантаженіДані = ДемонстраціяСеріалізації.завантажитиОбєкт("дані_обчислення.ser");
        if (завантаженіДані != null) {
            System.out.println("Завантажений параметр1: " + завантаженіДані.отриматиПараметр1());
            System.out.println("Завантажений параметр2: " + завантаженіДані.отриматиПараметр2());
            System.out.println("Завантажений результат (transient): " + завантаженіДані.отриматиРезультат());
        }

        ТестОбчислень.тестуватиОбчислення();
        ТестОбчислень.тестуватиСеріалізацію();

        int число = 10;
        System.out.println("Число: " + число);
        System.out.println("Двійкове подання: " + Integer.toBinaryString(число));
        System.out.println("Кількість чергувань 0 та 1: " + порахуватиЧергування(число));
    }
}


day 3 
//
pr2
123


import java.io.Serializable;
import java.io.*;
import java.util.ArrayList;

class ДаніОбчислення implements Serializable {
    private final double параметр1;
    private final double параметр2;
    private transient double результат;

    ДаніОбчислення(double парам1, double парам2) {
        this.параметр1 = парам1;
        this.параметр2 = парам2;
        this.результат = 0.0;
    }

    void обчислитиРезультат() {
        this.результат = параметр1 + параметр2;
    }

    double отриматиПараметр1() {
        return параметр1;
    }

    double отриматиПараметр2() {
        return параметр2;
    }

    double отриматиРезультат() {
        return результат;
    }
}

class Калькулятор {
    private final ДаніОбчислення дані;

    Калькулятор(double парам1, double парам2) {
        this.дані = new ДаніОбчислення(парам1, парам2);
        this.дані.обчислитиРезультат();
    }

    double отриматиРезультат() {
        return дані.отриматиРезультат();
    }

    ДаніОбчислення отриматиДані() {
        return дані;
    }
}

class ДемонстраціяСеріалізації {
    static void зберегтиОбєкт(ДаніОбчислення дані, String імʼяФайлу) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(імʼяФайлу))) {
            out.writeObject(дані);
            System.out.println("Обʼєкт успішно збережено");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static ДаніОбчислення завантажитиОбєкт(String імʼяФайлу) {
        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(імʼяФайлу))) {
            ДаніОбчислення дані = (ДаніОбчислення) in.readObject();
            System.out.println("Обʼєкт успішно завантажено");
            return дані;
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }

    static void зберегтиКолекцію(ArrayList<ДаніОбчислення> колекція, String імʼяФайлу) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(імʼяФайлу))) {
            out.writeObject(колекція);
            System.out.println("Колекція успішно збережена");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @SuppressWarnings("unchecked")
    static ArrayList<ДаніОбчислення> завантажитиКолекцію(String імʼяФайлу) {
        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(імʼяФайлу))) {
            ArrayList<ДаніОбчислення> колекція = (ArrayList<ДаніОбчислення>) in.readObject();
            System.out.println("Колекція успішно завантажена");
            return колекція;
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
}

class ТестОбчислень {
    static void тестуватиОбчислення() {
        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        double очікуваний = 8.0;
        double фактичний = калькулятор.отриматиРезультат();
        
        if (Math.abs(очікуваний - фактичний) < 0.0001) {
            System.out.println("Тест обчислень пройдено");
        } else {
            System.out.println("Тест обчислень не пройдено: очікувалось " + очікуваний + ", отримано " + фактичний);
        }
    }

    static void тестуватиСеріалізацію() {
        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        ДемонстраціяСеріалізації.зберегтиОбєкт(калькулятор.отриматиДані(), "тест.ser");
        
        ДаніОбчислення завантажені = ДемонстраціяСеріалізації.завантажитиОбєкт("тест.ser");
        if (завантажені != null && 
            Math.abs(завантажені.отриматиПараметр1() - 5.0) < 0.0001 && 
            Math.abs(завантажені.отриматиПараметр2() - 3.0) < 0.0001) {
            System.out.println("Тест серіалізації пройдено");
        } else {
            System.out.println("Тест серіалізації не пройдено");
        }
        
        if (завантажені != null && завантажені.отриматиРезультат() == 0.0) {
            System.out.println("Тест поля transient пройдено");
        } else {
            System.out.println("Тест поля transient не пройдено");
        }
    }
}

interface Відображуваний {
    void відобразитиПараметри();
    void відобразитиРезультат();
}

interface ФабрикаВідображення {
    Відображуваний створитиВідображувач(ДаніОбчислення дані);
}

class ТекстовийВідображувачПараметри implements Відображуваний {
    private final ДаніОбчислення дані;

    ТекстовийВідображувачПараметри(ДаніОбчислення дані) {
        this.дані = дані;
    }

    public void відобразитиПараметри() {
        System.out.println("Параметр 1: " + дані.отриматиПараметр1() + ", Параметр 2: " + дані.отриматиПараметр2());
    }

    public void відобразитиРезультат() {
        System.out.println("Результат (лише параметри): недоступно");
    }
}

class ТекстовийВідображувачРезультат implements Відображуваний {
    private final ДаніОбчислення дані;

    ТекстовийВідображувачРезультат(ДаніОбчислення дані) {
        this.дані = дані;
    }

    public void відобразитиПараметри() {
        System.out.println("Параметри (лише результат): недоступно");
    }

    public void відобразитиРезультат() {
        System.out.println("Результат: " + дані.отриматиРезультат());
    }
}

class ФабрикаПараметри implements ФабрикаВідображення {
    public Відображуваний створитиВідображувач(ДаніОбчислення дані) {
        return new ТекстовийВідображувачПараметри(дані);
    }
}

class ФабрикаРезультат implements ФабрикаВідображення {
    public Відображуваний створитиВідображувач(ДаніОбчислення дані) {
        return new ТекстовийВідображувачРезультат(дані);
    }
}

public class Main {
    static int порахуватиЧергування(int число) {
        String двійковеПодання = Integer.toBinaryString(число);
        int кількістьЧергувань = 0;
        
        for (int i = 1; i < двійковеПодання.length(); i++) {
            if (двійковеПодання.charAt(i) != двійковеПодання.charAt(i - 1)) {
                кількістьЧергувань++;
            }
        }
        return кількістьЧергувань;
    }

    public static void main(String[] args) {
        System.out.println("Группа: 34");
        System.out.println("Учитель: Олейник");
        System.out.println("Аргументы командной строки:");
        for (String arg : args) {
            System.out.println(arg);
        }

        ArrayList<ДаніОбчислення> колекціяОбчислень = new ArrayList<>();
        Калькулятор калькулятор1 = new Калькулятор(5.0, 3.0);
        Калькулятор калькулятор2 = new Калькулятор(10.0, 20.0);
        колекціяОбчислень.add(калькулятор1.отриматиДані());
        колекціяОбчислень.add(калькулятор2.отриматиДані());
        System.out.println("Результат 1: " + калькулятор1.отриматиРезультат());
        System.out.println("Результат 2: " + калькулятор2.отриматиРезультат());

        ДемонстраціяСеріалізації.зберегтиКолекцію(колекціяОбчислень, "колекція_обчислень.ser");
        ArrayList<ДаніОбчислення> завантаженаКолекція = ДемонстраціяСеріалізації.завантажитиКолекцію("колекція_обчислень.ser");

        if (завантаженаКолекція != null) {
            for (ДаніОбчислення дані : завантаженаКолекція) {
                System.out.println("Завантажені параметри: " + дані.отриматиПараметр1() + ", " + дані.отриматиПараметр2());
            }
        }

        ДемонстраціяСеріалізації.зберегтиОбєкт(калькулятор1.отриматиДані(), "дані_обчислення.ser");
        ДаніОбчислення завантаженіДані = ДемонстраціяСеріалізації.завантажитиОбєкт("дані_обчислення.ser");
        if (завантаженіДані != null) {
            System.out.println("Завантажений параметр1: " + завантаженіДані.отриматиПараметр1());
            System.out.println("Завантажений параметр2: " + завантаженіДані.отриматиПараметр2());
            System.out.println("Завантажений результат (transient): " + завантаженіДані.отриматиРезультат());
        }

        ТестОбчислень.тестуватиОбчислення();
        ТестОбчислень.тестуватиСеріалізацію();

        int число = 10;
        System.out.println("Число: " + число);
        System.out.println("Двійкове подання: " + Integer.toBinaryString(число));
        System.out.println("Кількість чергувань 0 та 1: " + порахуватиЧергування(число));

        ФабрикаВідображення фабрикаПараметри = new ФабрикаПараметри();
        ФабрикаВідображення фабрикаРезультат = new ФабрикаРезультат();
        Відображуваний відображувачПараметри = фабрикаПараметри.створитиВідображувач(калькулятор1.отриматиДані());
        Відображуваний відображувачРезультат = фабрикаРезультат.створитиВідображувач(калькулятор1.отриматиДані());
        відображувачПараметри.відобразитиПараметри();
        відображувачПараметри.відобразитиРезультат();
        відображувачРезультат.відобразитиПараметри();
        відображувачРезультат.відобразитиРезультат();
    }
}



day 4
//
pr2
123

import java.io.Serializable;
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Клас, що представляє дані для обчислень, які можна серіалізувати.
 */
class ДаніОбчислення implements Serializable {
    private final double параметр1;
    private final double параметр2;
    private transient double результат;

    /**
     * Конструктор для створення об’єкта ДаніОбчислення.
     * @param парам1 Перший параметр для обчислень.
     * @param парам2 Другий параметр для обчислень.
     */
    ДаніОбчислення(double парам1, double парам2) {
        this.параметр1 = парам1;
        this.параметр2 = парам2;
        this.результат = 0.0;
    }

    /**
     * Обчислює результат як суму параметрів.
     */
    void обчислитиРезультат() {
        this.результат = параметр1 + параметр2;
    }

    /**
     * Повертає перший параметр.
     * @return Перший параметр.
     */
    double отриматиПараметр1() {
        return параметр1;
    }

    /**
     * Повертає другий параметр.
     * @return Другий параметр.
     */
    double отриматиПараметр2() {
        return параметр2;
    }

    /**
     * Повертає результат обчислень.
     * @return Результат обчислень.
     */
    double отриматиРезультат() {
        return результат;
    }
}

/**
 * Клас для виконання обчислень на основі даних.
 */
class Калькулятор {
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення калькулятора.
     * @param парам1 Перший параметр.
     * @param парам2 Другий параметр.
     */
    Калькулятор(double парам1, double парам2) {
        this.дані = new ДаніОбчислення(парам1, парам2);
        this.дані.обчислитиРезультат();
    }

    /**
     * Повертає результат обчислень.
     * @return Результат обчислень.
     */
    double отриматиРезультат() {
        return дані.отриматиРезультат();
    }

    /**
     * Повертає об’єкт даних.
     * @return Об’єкт ДаніОбчислення.
     */
    ДаніОбчислення отриматиДані() {
        return дані;
    }
}

/**
 * Клас для демонстрації серіалізації та десеріалізації колекцій.
 */
class ДемонстраціяСеріалізації {
    /**
     * Зберігає колекцію у файл.
     * @param колекція Колекція для збереження.
     * @param імʼяФайлу Ім’я файлу для збереження.
     */
    static void зберегтиКолекцію(ArrayList<ДаніОбчислення> колекція, String імʼяФайлу) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(імʼяФайлу))) {
            out.writeObject(колекція);
            System.out.println("Колекція успішно збережена");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Завантажує колекцію з файлу.
     * @param імʼяФайлу Ім’я файлу для завантаження.
     * @return Завантажена колекція.
     */
    @SuppressWarnings("unchecked")
    static ArrayList<ДаніОбчислення> завантажитиКолекцію(String імʼяФайлу) {
        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(імʼяФайлу))) {
            ArrayList<ДаніОбчислення> колекція = (ArrayList<ДаніОбчислення>) in.readObject();
            System.out.println("Колекція успішно завантажена");
            return колекція;
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
}

/**
 * Інтерфейс для об’єктів, які можуть відображати результати обчислень.
 */
interface Відображуваний {
    /**
     * Відображає параметри обчислень.
     */
    void відобразитиПараметри();

    /**
     * Відображає результат обчислень.
     */
    void відобразитиРезультат();

    /**
     * Відображає дані у вигляді таблиці з заданою шириною стовпців.
     * @param ширинаСтовпця Ширина стовпців таблиці.
     */
    void відобразитиЯкТаблицю(int ширинаСтовпця);
}

/**
 * Інтерфейс для фабрики, яка створює відображувачі.
 */
interface ФабрикаВідображення {
    /**
     * Створює відображувач для даних.
     * @param дані Дані для відображення.
     * @return Об’єкт, що реалізує Відображуваний.
     */
    Відображуваний створитиВідображувач(ДаніОбчислення дані);
}

/**
 * Клас для текстового відображення параметрів.
 */
class ТекстовийВідображувачПараметри implements Відображуваний {
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення відображувача параметрів.
     * @param дані Дані для відображення.
     */
    ТекстовийВідображувачПараметри(ДаніОбчислення дані) {
        this.дані = дані;
    }

    public void відобразитиПараметри() {
        System.out.println("Параметр 1: " + дані.отриматиПараметр1() + ", Параметр 2: " + дані.отриматиПараметр2());
    }

    public void відобразитиРезультат() {
        System.out.println("Результат (лише параметри): недоступно");
    }

    public void відобразитиЯкТаблицю(int ширинаСтовпця) {
        System.out.println("Відображення параметрів у вигляді таблиці:");
        String заголовок = String.format("|%-" + ширинаСтовпця + "s|%-" + ширинаСтовпця + "s|", "Параметр 1", "Параметр 2");
        String роздільник = "-".repeat(заголовок.length());
        String рядок = String.format("|%-" + ширинаСтовпця + ".2f|%-" + ширинаСтовпця + ".2f|", дані.отриматиПараметр1(), дані.отриматиПараметр2());
        System.out.println(роздільник);
        System.out.println(заголовок);
        System.out.println(роздільник);
        System.out.println(рядок);
        System.out.println(роздільник);
    }
}

/**
 * Клас для текстового відображення результату.
 */
class ТекстовийВідображувачРезультат implements Відображуваний {
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення відображувача результату.
     * @param дані Дані для відображення.
     */
    ТекстовийВідображувачРезультат(ДаніОбчислення дані) {
        this.дані = дані;
    }

    public void відобразитиПараметри() {
        System.out.println("Параметри (лише результат): недоступно");
    }

    public void відобразитиРезультат() {
        System.out.println("Результат: " + дані.отриматиРезультат());
    }

    public void відобразитиЯкТаблицю(int ширинаСтовпця) {
        System.out.println("Відображення результату у вигляді таблиці:");
        String заголовок = String.format("|%-" + ширинаСтовпця + "s|", "Результат");
        String роздільник = "-".repeat(заголовок.length());
        String рядок = String.format("|%-" + ширинаСтовпця + ".2f|", дані.отриматиРезультат());
        System.out.println(роздільник);
        System.out.println(заголовок);
        System.out.println(роздільник);
        System.out.println(рядок);
        System.out.println(роздільник);
    }
}

/**
 * Клас для повного текстового відображення (параметри + результат).
 */
class ТекстовийВідображувачПовний implements Відображуваний {
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення повного відображувача.
     * @param дані Дані для відображення.
     */
    ТекстовийВідображувачПовний(ДаніОбчислення дані) {
        this.дані = дані;
    }

    public void відобразитиПараметри() {
        System.out.println("Параметр 1: " + дані.отриматиПараметр1() + ", Параметр 2: " + дані.отриматиПараметр2());
    }

    public void відобразитиРезультат() {
        System.out.println("Результат: " + дані.отриматиРезультат());
    }

    public void відобразитиЯкТаблицю(int ширинаСтовпця) {
        System.out.println("Повне відображення у вигляді таблиці:");
        String заголовок = String.format("|%-" + ширинаСтовпця + "s|%-" + ширинаСтовпця + "s|%-" + ширинаСтовпця + "s|", "Параметр 1", "Параметр 2", "Результат");
        String роздільник = "-".repeat(заголовок.length());
        String рядок = String.format("|%-" + ширинаСтовпця + ".2f|%-" + ширинаСтовпця + ".2f|%-" + ширинаСтовпця + ".2f|", 
                                     дані.отриматиПараметр1(), дані.отриматиПараметр2(), дані.отриматиРезультат());
        System.out.println(роздільник);
        System.out.println(заголовок);
        System.out.println(роздільник);
        System.out.println(рядок);
        System.out.println(роздільник);
    }

    /**
     * Перевантажений метод для відображення таблиці з додатковим заголовком.
     * @param ширинаСтовпця Ширина стовпців таблиці.
     * @param заголовокТаблиці Заголовок таблиці.
     */
    public void відобразитиЯкТаблицю(int ширинаСтовпця, String заголовокТаблиці) {
        System.out.println(заголовокТаблиці);
        відобразитиЯкТаблицю(ширинаСтовпця);
    }
}

/**
 * Фабрика для створення відображувача параметрів.
 */
class ФабрикаПараметри implements ФабрикаВідображення {
    public Відображуваний створитиВідображувач(ДаніОбчислення дані) {
        return new ТекстовийВідображувачПараметри(дані);
    }
}

/**
 * Фабрика для створення відображувача результату.
 */
class ФабрикаРезультат implements ФабрикаВідображення {
    public Відображуваний створитиВідображувач(ДаніОбчислення дані) {
        return new ТекстовийВідображувачРезультат(дані);
    }
}

/**
 * Фабрика для створення повного відображувача.
 */
class ФабрикаПовний implements ФабрикаВідображення {
    public Відображуваний створитиВідображувач(ДаніОбчислення дані) {
        return new ТекстовийВідображувачПовний(дані);
    }
}

/**
 * Клас для тестування основної функціональності.
 */
class ТестФункціональності {
    /**
     * Тестує створення відображувачів і відображення даних.
     */
    static void тестуватиВідображення() {
        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        ФабрикаВідображення фабрикаПараметри = new ФабрикаПараметри();
        ФабрикаВідображення фабрикаРезультат = new ФабрикаРезультат();
        ФабрикаВідображення фабрикаПовний = new ФабрикаПовний();

        Відображуваний відображувачПараметри = фабрикаПараметри.створитиВідображувач(калькулятор.отриматиДані());
        Відображуваний відображувачРезультат = фабрикаРезультат.створитиВідображувач(калькулятор.отриматиДані());
        Відображуваний відображувачПовний = фабрикаПовний.створитиВідображувач(калькулятор.отриматиДані());

        відображувачПараметри.відобразитиПараметри();
        відображувачРезультат.відобразитиРезультат();
        відображувачПовний.відобразитиЯкТаблицю(15);
    }

    /**
     * Тестує збереження та завантаження колекції.
     */
    static void тестуватиСеріалізацію() {
        ArrayList<ДаніОбчислення> колекція = new ArrayList<>();
        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        колекція.add(калькулятор.отриматиДані());

        ДемонстраціяСеріалізації.зберегтиКолекцію(колекція, "тест_колекція.ser");
        ArrayList<ДаніОбчислення> завантаженаКолекція = ДемонстраціяСеріалізації.завантажитиКолекцію("тест_колекція.ser");

        if (завантаженаКолекція != null && завантаженаКолекція.size() == 1) {
            ДаніОбчислення дані = завантаженаКолекція.get(0);
            if (Math.abs(дані.отриматиПараметр1() - 5.0) < 0.0001 && Math.abs(дані.отриматиПараметр2() - 3.0) < 0.0001) {
                System.out.println("Тест серіалізації пройдено");
            } else {
                System.out.println("Тест серіалізації не пройдено");
            }
        } else {
            System.out.println("Тест серіалізації не пройдено: колекція не завантажена");
        }
    }
}

/**
 * Основний клас програми.
 */
public class Main {
    /**
     * Основний метод програми.
     * @param args Аргументи командного рядка.
     */
    public static void main(String[] args) {
        Scanner сканер = new Scanner(System.in);

        System.out.println("Введіть перший параметр:");
        double парам1 = сканер.nextDouble();
        System.out.println("Введіть другий параметр:");
        double парам2 = сканер.nextDouble();

        ArrayList<ДаніОбчислення> колекціяОбчислень = new ArrayList<>();
        Калькулятор калькулятор = new Калькулятор(парам1, парам2);
        колекціяОбчислень.add(калькулятор.отриматиДані());
        System.out.println("Результат: " + калькулятор.отриматиРезультат());

        ДемонстраціяСеріалізації.зберегтиКолекцію(колекціяОбчислень, "колекція_обчислень.ser");
        ArrayList<ДаніОбчислення> завантаженаКолекція = ДемонстраціяСеріалізації.завантажитиКолекцію("колекція_обчислень.ser");

        if (завантаженаКолекція != null) {
            for (ДаніОбчислення дані : завантаженаКолекція) {
                System.out.println("Завантажені параметри: " + дані.отриматиПараметр1() + ", " + дані.отриматиПараметр2());
            }
        }

        System.out.println("Введіть ширину стовпця для таблиці:");
        int ширинаСтовпця = сканер.nextInt();

        ФабрикаВідображення фабрикаПараметри = new ФабрикаПараметри();
        ФабрикаВідображення фабрикаРезультат = new ФабрикаРезультат();
        ФабрикаВідображення фабрикаПовний = new ФабрикаПовний();

        Відображуваний відображувачПараметри = фабрикаПараметри.створитиВідображувач(калькулятор.отриматиДані());
        Відображуваний відображувачРезультат = фабрикаРезультат.створитиВідображувач(калькулятор.отриматиДані());
        Відображуваний відображувачПовний = фабрикаПовний.створитиВідображувач(калькулятор.отриматиДані());

        відображувачПараметри.відобразитиПараметри();
        відображувачПараметри.відобразитиРезультат();
        відображувачПараметри.відобразитиЯкТаблицю(ширинаСтовпця);

        відображувачРезультат.відобразитиПараметри();
        відображувачРезультат.відобразитиРезультат();
        відображувачРезультат.відобразитиЯкТаблицю(ширинаСтовпця);

        відображувачПовний.відобразитиПараметри();
        відображувачПовний.відобразитиРезультат();
        відображувачПовний.відобразитиЯкТаблицю(ширинаСтовпця);
        ((ТекстовийВідображувачПовний) відображувачПовний).відобразитиЯкТаблицю(ширинаСтовпця, "Повна таблиця обчислень");

        ТестФункціональності.тестуватиВідображення();
        ТестФункціональності.тестуватиСеріалізацію();

        сканер.close();
    }
}




day 5 
123
//

import java.io.Serializable;
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Stack;

/**
 * Клас, що представляє дані для обчислень, які можна серіалізувати.
 */
class ДаніОбчислення implements Serializable {
    private final double параметр1;
    private final double параметр2;
    private transient double результат;

    /**
     * Конструктор для створення об’єкта ДаніОбчислення.
     * @param парам1 Перший параметр для обчислень.
     * @param парам2 Другий параметр для обчислень.
     */
    ДаніОбчислення(double парам1, double парам2) {
        this.параметр1 = парам1;
        this.параметр2 = парам2;
        this.результат = 0.0;
    }

    /**
     * Обчислює результат як суму параметрів.
     */
    void обчислитиРезультат() {
        this.результат = параметр1 + параметр2;
    }

    /**
     * Повертає перший параметр.
     * @return Перший параметр.
     */
    double отриматиПараметр1() {
        return параметр1;
    }

    /**
     * Повертає другий параметр.
     * @return Другий параметр.
     */
    double отриматиПараметр2() {
        return параметр2;
    }

    /**
     * Повертає результат обчислень.
     * @return Результат обчислень.
     */
    double отриматиРезультат() {
        return результат;
    }
}

/**
 * Клас для виконання обчислень на основі даних.
 */
class Калькулятор {
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення калькулятора.
     * @param парам1 Перший параметр.
     * @param парам2 Другий параметр.
     */
    Калькулятор(double парам1, double парам2) {
        this.дані = new ДаніОбчислення(парам1, парам2);
        this.дані.обчислитиРезультат();
    }

    /**
     * Повертає результат обчислень.
     * @return Результат обчислень.
     */
    double отриматиРезультат() {
        return дані.отриматиРезультат();
    }

    /**
     * Повертає об’єкт даних.
     * @return Об’єкт ДаніОбчислення.
     */
    ДаніОбчислення отриматиДані() {
        return дані;
    }
}

/**
 * Клас для демонстрації серіалізації та десеріалізації колекцій.
 */
class ДемонстраціяСеріалізації {
    /**
     * Зберігає колекцію у файл.
     * @param колекція Колекція для збереження.
     * @param імʼяФайлу Ім’я файлу для збереження.
     */
    static void зберегтиКолекцію(ArrayList<ДаніОбчислення> колекція, String імʼяФайлу) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(імʼяФайлу))) {
            out.writeObject(колекція);
            System.out.println("Колекція успішно збережена");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Завантажує колекцію з файлу.
     * @param імʼяФайлу Ім’я файлу для завантаження.
     * @return Завантажена колекція.
     */
    @SuppressWarnings("unchecked")
    static ArrayList<ДаніОбчислення> завантажитиКолекцію(String імʼяФайлу) {
        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(імʼяФайлу))) {
            ArrayList<ДаніОбчислення> колекція = (ArrayList<ДаніОбчислення>) in.readObject();
            System.out.println("Колекція успішно завантажена");
            return колекція;
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
}

/**
 * Інтерфейс для команд, які можна виконувати та скасовувати.
 */
interface Команда {
    /**
     * Виконує команду.
     */
    void виконати();

    /**
     * Скасовує команду.
     */
    void скасувати();
}

/**
 * Команда для додавання обчислень до колекції.
 */
class КомандаДодатиОбчислення implements Команда {
    private final ArrayList<ДаніОбчислення> колекція;
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення команди додавання.
     * @param колекція Колекція для додавання.
     * @param дані Дані для додавання.
     */
    КомандаДодатиОбчислення(ArrayList<ДаніОбчислення> колекція, ДаніОбчислення дані) {
        this.колекція = колекція;
        this.дані = дані;
    }

    public void виконати() {
        колекція.add(дані);
        System.out.println("Додано обчислення: " + дані.отриматиПараметр1() + " + " + дані.отриматиПараметр2());
    }

    public void скасувати() {
        колекція.remove(дані);
        System.out.println("Скасовано додавання обчислення: " + дані.отриматиПараметр1() + " + " + дані.отриматиПараметр2());
    }
}

/**
 * Команда для збереження колекції.
 */
class КомандаЗберегтиКолекцію implements Команда {
    private final ArrayList<ДаніОбчислення> колекція;
    private final String імʼяФайлу;

    /**
     * Конструктор для створення команди збереження.
     * @param колекція Колекція для збереження.
     * @param імʼяФайлу Ім’я файлу для збереження.
     */
    КомандаЗберегтиКолекцію(ArrayList<ДаніОбчислення> колекція, String імʼяФайлу) {
        this.колекція = колекція;
        this.імʼяФайлу = імʼяФайлу;
    }

    public void виконати() {
        ДемонстраціяСеріалізації.зберегтиКолекцію(колекція, імʼяФайлу);
    }

    public void скасувати() {
        System.out.println("Скасування збереження колекції не підтримується");
    }
}

/**
 * Макрокоманда, яка виконує кілька команд послідовно.
 */
class Макрокоманда implements Команда {
    private final ArrayList<Команда> команди;

    /**
     * Конструктор для створення макрокоманди.
     * @param команди Список команд для виконання.
     */
    Макрокоманда(ArrayList<Команда> команди) {
        this.команди = команди;
    }

    public void виконати() {
        for (Команда команда : команди) {
            команда.виконати();
        }
        System.out.println("Макрокоманда виконана");
    }

    public void скасувати() {
        for (int i = команди.size() - 1; i >= 0; i--) {
            команди.get(i).скасувати();
        }
        System.out.println("Макрокоманда скасована");
    }
}

/**
 * Клас-менеджер команд, що використовує шаблон Singleton.
 */
class МенеджерКоманд {
    private static МенеджерКоманд екземпляр;
    private final Stack<Команда> історіяКоманд;

    private МенеджерКоманд() {
        історіяКоманд = new Stack<>();
    }

    /**
     * Повертає єдиний екземпляр менеджера команд.
     * @return Екземпляр МенеджерКоманд.
     */
    static МенеджерКоманд отриматиЕкземпляр() {
        if (екземпляр == null) {
            екземпляр = new МенеджерКоманд();
        }
        return екземпляр;
    }

    /**
     * Виконує команду та додає її до історії.
     * @param команда Команда для виконання.
     */
    void виконатиКоманду(Команда команда) {
        команда.виконати();
        історіяКоманд.push(команда);
    }

    /**
     * Скасовує останню команду.
     */
    void скасуватиОстаннюКоманду() {
        if (!історіяКоманд.isEmpty()) {
            Команда команда = історіяКоманд.pop();
            команда.скасувати();
        } else {
            System.out.println("Немає команд для скасування");
        }
    }
}

/**
 * Інтерфейс для об’єктів, які можуть відображати результати обчислень.
 */
interface Відображуваний {
    /**
     * Відображає параметри обчислень.
     */
    void відобразитиПараметри();

    /**
     * Відображає результат обчислень.
     */
    void відобразитиРезультат();

    /**
     * Відображає дані у вигляді таблиці з заданою шириною стовпців.
     * @param ширинаСтовпця Ширина стовпців таблиці.
     */
    void відобразитиЯкТаблицю(int ширинаСтовпця);
}

/**
 * Інтерфейс для фабрики, яка створює відображувачі.
 */
interface ФабрикаВідображення {
    /**
     * Створює відображувач для даних.
     * @param дані Дані для відображення.
     * @return Об’єкт, що реалізує Відображуваний.
     */
    Відображуваний створитиВідображувач(ДаніОбчислення дані);
}

/**
 * Клас для текстового відображення параметрів.
 */
class ТекстовийВідображувачПараметри implements Відображуваний {
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення відображувача параметрів.
     * @param дані Дані для відображення.
     */
    ТекстовийВідображувачПараметри(ДаніОбчислення дані) {
        this.дані = дані;
    }

    public void відобразитиПараметри() {
        System.out.println("Параметр 1: " + дані.отриматиПараметр1() + ", Параметр 2: " + дані.отриматиПараметр2());
    }

    public void відобразитиРезультат() {
        System.out.println("Результат (лише параметри): недоступно");
    }

    public void відобразитиЯкТаблицю(int ширинаСтовпця) {
        System.out.println("Відображення параметрів у вигляді таблиці:");
        String заголовок = String.format("|%-" + ширинаСтовпця + "s|%-" + ширинаСтовпця + "s|", "Параметр 1", "Параметр 2");
        String роздільник = "-".repeat(заголовок.length());
        String рядок = String.format("|%-" + ширинаСтовпця + ".2f|%-" + ширинаСтовпця + ".2f|", дані.отриматиПараметр1(), дані.отриматиПараметр2());
        System.out.println(роздільник);
        System.out.println(заголовок);
        System.out.println(роздільник);
        System.out.println(рядок);
        System.out.println(роздільник);
    }
}

/**
 * Клас для текстового відображення результату.
 */
class ТекстовийВідображувачРезультат implements Відображуваний {
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення відображувача результату.
     * @param дані Дані для відображення.
     */
    ТекстовийВідображувачРезультат(ДаніОбчислення дані) {
        this.дані = дані;
    }

    public void відобразитиПараметри() {
        System.out.println("Параметри (лише результат): недоступно");
    }

    public void відобразитиРезультат() {
        System.out.println("Результат: " + дані.отриматиРезультат());
    }

    public void відобразитиЯкТаблицю(int ширинаСтовпця) {
        System.out.println("Відображення результату у вигляді таблиці:");
        String заголовок = String.format("|%-" + ширинаСтовпця + "s|", "Результат");
        String роздільник = "-".repeat(заголовок.length());
        String рядок = String.format("|%-" + ширинаСтовпця + ".2f|", дані.отриматиРезультат());
        System.out.println(роздільник);
        System.out.println(заголовок);
        System.out.println(роздільник);
        System.out.println(рядок);
        System.out.println(роздільник);
    }
}

/**
 * Клас для повного текстового відображення (параметри + результат).
 */
class ТекстовийВідображувачПовний implements Відображуваний {
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення повного відображувача.
     * @param дані Дані для відображення.
     */
    ТекстовийВідображувачПовний(ДаніОбчислення дані) {
        this.дані = дані;
    }

    public void відобразитиПараметри() {
        System.out.println("Параметр 1: " + дані.отриматиПараметр1() + ", Параметр 2: " + дані.отриматиПараметр2());
    }

    public void відобразитиРезультат() {
        System.out.println("Результат: " + дані.отриматиРезультат());
    }

    public void відобразитиЯкТаблицю(int ширинаСтовпця) {
        System.out.println("Повне відображення у вигляді таблиці:");
        String заголовок = String.format("|%-" + ширинаСтовпця + "s|%-" + ширинаСтовпця + "s|%-" + ширинаСтовпця + "s|", "Параметр 1", "Параметр 2", "Результат");
        String роздільник = "-".repeat(заголовок.length());
        String рядок = String.format("|%-" + ширинаСтовпця + ".2f|%-" + ширинаСтовпця + ".2f|%-" + ширинаСтовпця + ".2f|", 
                                     дані.отриматиПараметр1(), дані.отриматиПараметр2(), дані.отриматиРезультат());
        System.out.println(роздільник);
        System.out.println(заголовок);
        System.out.println(роздільник);
        System.out.println(рядок);
        System.out.println(роздільник);
    }

    /**
     * Перевантажений метод для відображення таблиці з додатковим заголовком.
     * @param ширинаСтовпця Ширина стовпців таблиці.
     * @param заголовокТаблиці Заголовок таблиці.
     */
    public void відобразитиЯкТаблицю(int ширинаСтовпця, String заголовокТаблиці) {
        System.out.println(заголовокТаблиці);
        відобразитиЯкТаблицю(ширинаСтовпця);
    }
}

/**
 * Фабрика для створення відображувача параметрів.
 */
class ФабрикаПараметри implements ФабрикаВідображення {
    public Відображуваний створитиВідображувач(ДаніОбчислення дані) {
        return new ТекстовийВідображувачПараметри(дані);
    }
}

/**
 * Фабрика для створення відображувача результату.
 */
class ФабрикаРезультат implements ФабрикаВідображення {
    public Відображуваний створитиВідображувач(ДаніОбчислення дані) {
        return new ТекстовийВідображувачРезультат(дані);
    }
}

/**
 * Фабрика для створення повного відображувача.
 */
class ФабрикаПовний implements ФабрикаВідображення {
    public Відображуваний створитиВідображувач(ДаніОбчислення дані) {
        return new ТекстовийВідображувачПовний(дані);
    }
}

/**
 * Клас для тестування основної функціональності.
 */
class ТестФункціональності {
    /**
     * Тестує створення відображувачів і відображення даних.
     */
    static void тестуватиВідображення() {
        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        ФабрикаВідображення фабрикаПараметри = new ФабрикаПараметри();
        ФабрикаВідображення фабрикаРезультат = new ФабрикаРезультат();
        ФабрикаВідображення фабрикаПовний = new ФабрикаПовний();

        Відображуваний відображувачПараметри = фабрикаПараметри.створитиВідображувач(калькулятор.отриматиДані());
        Відображуваний відображувачРезультат = фабрикаРезультат.створитиВідображувач(калькулятор.отриматиДані());
        Відображуваний відображувачПовний = фабрикаПовний.створитиВідображувач(калькулятор.отриматиДані());

        відображувачПараметри.відобразитиПараметри();
        відображувачРезультат.відобразитиРезультат();
        відображувачПовний.відобразитиЯкТаблицю(15);
    }

    /**
     * Тестує збереження та завантаження колекції.
     */
    static void тестуватиСеріалізацію() {
        ArrayList<ДаніОбчислення> колекція = new ArrayList<>();
        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        колекція.add(калькулятор.отриматиДані());

        ДемонстраціяСеріалізації.зберегтиКолекцію(колекція, "тест_колекція.ser");
        ArrayList<ДаніОбчислення> завантаженаКолекція = ДемонстраціяСеріалізації.завантажитиКолекцію("тест_колекція.ser");

        if (завантаженаКолекція != null && завантаженаКолекція.size() == 1) {
            ДаніОбчислення дані = завантаженаКолекція.get(0);
            if (Math.abs(дані.отриматиПараметр1() - 5.0) < 0.0001 && Math.abs(дані.отриматиПараметр2() - 3.0) < 0.0001) {
                System.out.println("Тест серіалізації пройдено");
            } else {
                System.out.println("Тест серіалізації не пройдено");
            }
        } else {
            System.out.println("Тест серіалізації не пройдено: колекція не завантажена");
        }
    }

    /**
     * Тестує виконання та скасування команд.
     */
    static void тестуватиКоманди() {
        ArrayList<ДаніОбчислення> колекція = new ArrayList<>();
        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        МенеджерКоманд менеджер = МенеджерКоманд.отриматиЕкземпляр();

        Команда командаДодати = new КомандаДодатиОбчислення(колекція, калькулятор.отриматиДані());
        менеджер.виконатиКоманду(командаДодати);

        if (колекція.size() == 1) {
            System.out.println("Тест додавання обчислення пройдено");
        } else {
            System.out.println("Тест додавання обчислення не пройдено");
        }

        менеджер.скасуватиОстаннюКоманду();
        if (колекція.isEmpty()) {
            System.out.println("Тест скасування обчислення пройдено");
        } else {
            System.out.println("Тест скасування обчислення не пройдено");
        }
    }

    /**
     * Тестує виконання макрокоманди.
     */
    static void тестуватиМакрокоманду() {
        ArrayList<ДаніОбчислення> колекція = new ArrayList<>();
        Калькулятор калькулятор1 = new Калькулятор(5.0, 3.0);
        Калькулятор калькулятор2 = new Калькулятор(10.0, 20.0);
        МенеджерКоманд менеджер = МенеджерКоманд.отриматиЕкземпляр();

        ArrayList<Команда> команди = new ArrayList<>();
        команди.add(new КомандаДодатиОбчислення(колекція, калькулятор1.отриматиДані()));
        команди.add(new КомандаДодатиОбчислення(колекція, калькулятор2.отриматиДані()));
        команди.add(new КомандаЗберегтиКолекцію(колекція, "макро_тест.ser"));

        Команда макрокоманда = new Макрокоманда(команди);
        менеджер.виконатиКоманду(макрокоманда);

        if (колекція.size() == 2) {
            System.out.println("Тест макрокоманди пройдено");
        } else {
            System.out.println("Тест макрокоманди не пройдено");
        }

        менеджер.скасуватиОстаннюКоманду();
        if (колекція.isEmpty()) {
            System.out.println("Тест скасування макрокоманди пройдено");
        } else {
            System.out.println("Тест скасування макрокоманди не пройдено");
        }
    }
}

/**
 * Основний клас програми.
 */
public class Main {
    /**
     * Основний метод програми.
     * @param args Аргументи командного рядка.
     */
    public static void main(String[] args) {
        Scanner сканер = new Scanner(System.in);
        МенеджерКоманд менеджер = МенеджерКоманд.отриматиЕкземпляр();
        ArrayList<ДаніОбчислення> колекціяОбчислень = new ArrayList<>();

        while (true) {
            System.out.println("\nВиберіть дію:");
            System.out.println("1. Додати обчислення");
            System.out.println("2. Зберегти колекцію");
            System.out.println("3. Виконати макрокоманду (додати два обчислення та зберегти)");
            System.out.println("4. Скасувати останню дію");
            System.out.println("5. Відобразити результати");
            System.out.println("6. Запустити тести");
            System.out.println("7. Вийти");

            int вибір = сканер.nextInt();

            if (вибір == 7) {
                break;
            }

            if (вибір == 1) {
                System.out.println("Введіть перший параметр:");
                double парам1 = сканер.nextDouble();
                System.out.println("Введіть другий параметр:");
                double парам2 = сканер.nextDouble();
                Калькулятор калькулятор = new Калькулятор(парам1, парам2);
                Команда команда = new КомандаДодатиОбчислення(колекціяОбчислень, калькулятор.отриматиДані());
                менеджер.виконатиКоманду(команда);
            } else if (вибір == 2) {
                System.out.println("Введіть ім’я файлу для збереження:");
                String імʼяФайлу = сканер.next();
                Команда команда = new КомандаЗберегтиКолекцію(колекціяОбчислень, імʼяФайлу);
                менеджер.виконатиКоманду(команда);
            } else if (вибір == 3) {
                System.out.println("Введіть перший параметр для першого обчислення:");
                double парам1 = сканер.nextDouble();
                System.out.println("Введіть другий параметр для першого обчислення:");
                double парам2 = сканер.nextDouble();
                System.out.println("Введіть перший параметр для другого обчислення:");
                double парам3 = сканер.nextDouble();
                System.out.println("Введіть другий параметр для другого обчислення:");
                double парам4 = сканер.nextDouble();
                System.out.println("Введіть ім’я файлу для збереження:");
                String імʼяФайлу = сканер.next();

                Калькулятор калькулятор1 = new Калькулятор(парам1, парам2);
                Калькулятор калькулятор2 = new Калькулятор(парам3, парам4);
                ArrayList<Команда> команди = new ArrayList<>();
                команди.add(new КомандаДодатиОбчислення(колекціяОбчислень, калькулятор1.отриматиДані()));
                команди.add(new КомандаДодатиОбчислення(колекціяОбчислень, калькулятор2.отриматиДані()));
                команди.add(new КомандаЗберегтиКолекцію(колекціяОбчислень, імʼяФайлу));
                Команда макрокоманда = new Макрокоманда(команди);
                менеджер.виконатиКоманду(макрокоманда);
            } else if (вибір == 4) {
                менеджер.скасуватиОстаннюКоманду();
            } else if (вибір == 5) {
                if (колекціяОбчислень.isEmpty()) {
                    System.out.println("Колекція порожня");
                    continue;
                }
                System.out.println("Введіть ширину стовпця для таблиці:");
                int ширинаСтовпця = сканер.nextInt();

                ФабрикаВідображення фабрикаПараметри = new ФабрикаПараметри();
                ФабрикаВідображення фабрикаРезультат = new ФабрикаРезультат();
                ФабрикаВідображення фабрикаПовний = new ФабрикаПовний();

                for (ДаніОбчислення дані : колекціяОбчислень) {
                    Відображуваний відображувачПараметри = фабрикаПараметри.створитиВідображувач(дані);
                    Відображуваний відображувачРезультат = фабрикаРезультат.створитиВідображувач(дані);
                    Відображуваний відображувачПовний = фабрикаПовний.створитиВідображувач(дані);

                    відображувачПараметри.відобразитиПараметри();
                    відображувачПараметри.відобразитиРезультат();
                    відображувачПараметри.відобразитиЯкТаблицю(ширинаСтовпця);

                    відображувачРезультат.відобразитиПараметри();
                    відображувачРезультат.відобразитиРезультат();
                    відображувачРезультат.відобразитиЯкТаблицю(ширинаСтовпця);

                    відображувачПовний.відобразитиПараметри();
                    відображувачПовний.відобразитиРезультат();
                    відображувачПовний.відобразитиЯкТаблицю(ширинаСтовпця);
                    ((ТекстовийВідображувачПовний) відображувачПовний).відобразитиЯкТаблицю(ширинаСтовпця, "Повна таблиця обчислень");
                }
            } else if (вибір == 6) {
                ТестФункціональності.тестуватиВідображення();
                ТестФункціональності.тестуватиСеріалізацію();
                ТестФункціональності.тестуватиКоманди();
                ТестФункціональності.тестуватиМакрокоманду();
            } else {
                System.out.println("Невірний вибір. Спробуйте ще раз.");
            }
        }

       day 6
       123
       ///
  
       import java.io.Serializable;
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Stack;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.stream.Collectors;

/**
 * Клас, що представляє дані для обчислень, які можна серіалізувати.
 */
class ДаніОбчислення implements Serializable {
    private final double параметр1;
    private final double параметр2;
    private transient double результат;

    /**
     * Конструктор для створення об’єкта ДаніОбчислення.
     * @param парам1 Перший параметр для обчислень.
     * @param парам2 Другий параметр для обчислень.
     */
    ДаніОбчислення(double парам1, double парам2) {
        this.параметр1 = парам1;
        this.параметр2 = парам2;
        this.результат = 0.0;
    }

    /**
     * Обчислює результат як суму параметрів.
     */
    void обчислитиРезультат() {
        this.результат = параметр1 + параметр2;
    }

    /**
     * Повертає перший параметр.
     * @return Перший параметр.
     */
    double отриматиПараметр1() {
        return параметр1;
    }

    /**
     * Повертає другий параметр.
     * @return Другий параметр.
     */
    double отриматиПараметр2() {
        return параметр2;
    }

    /**
     * Повертає результат обчислень.
     * @return Результат обчислень.
     */
    double отриматиРезультат() {
        return результат;
    }
}

/**
 * Клас для виконання обчислень на основі даних.
 */
class Калькулятор {
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення калькулятора.
     * @param парам1 Перший параметр.
     * @param парам2 Другий параметр.
     */
    Калькулятор(double парам1, double парам2) {
        this.дані = new ДаніОбчислення(парам1, парам2);
        this.дані.обчислитиРезультат();
    }

    /**
     * Повертає результат обчислень.
     * @return Результат обчислень.
     */
    double отриматиРезультат() {
        return дані.отриматиРезультат();
    }

    /**
     * Повертає об’єкт даних.
     * @return Об’єкт ДаніОбчислення.
     */
    ДаніОбчислення отриматиДані() {
        return дані;
    }
}

/**
 * Клас для демонстрації серіалізації та десеріалізації колекцій.
 */
class ДемонстраціяСеріалізації {
    /**
     * Зберігає колекцію у файл.
     * @param колекція Колекція для збереження.
     * @param імʼяФайлу Ім’я файлу для збереження.
     */
    static void зберегтиКолекцію(ArrayList<ДаніОбчислення> колекція, String імʼяФайлу) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(імʼяФайлу))) {
            out.writeObject(колекція);
            System.out.println("Колекція успішно збережена");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Завантажує колекцію з файлу.
     * @param імʼяФайлу Ім’я файлу для завантаження.
     * @return Завантажена колекція.
     */
    @SuppressWarnings("unchecked")
    static ArrayList<ДаніОбчислення> завантажитиКолекцію(String імʼяФайлу) {
        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(імʼяФайлу))) {
            ArrayList<ДаніОбчислення> колекція = (ArrayList<ДаніОбчислення>) in.readObject();
            System.out.println("Колекція успішно завантажена");
            return колекція;
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
}

/**
 * Інтерфейс для команд, які можна виконувати та скасовувати.
 */
interface Команда {
    /**
     * Виконує команду.
     */
    void виконати();

    /**
     * Скасовує команду.
     */
    void скасувати();
}

/**
 * Команда для додавання обчислень до колекції.
 */
class КомандаДодатиОбчислення implements Команда {
    private final ArrayList<ДаніОбчислення> колекція;
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення команди додавання.
     * @param колекція Колекція для додавання.
     * @param дані Дані для додавання.
     */
    КомандаДодатиОбчислення(ArrayList<ДаніОбчислення> колекція, ДаніОбчислення дані) {
        this.колекція = колекція;
        this.дані = дані;
    }

    public void виконати() {
        колекція.add(дані);
        System.out.println("Додано обчислення: " + дані.отриматиПараметр1() + " + " + дані.отриматиПараметр2());
    }

    public void скасувати() {
        колекція.remove(дані);
        System.out.println("Скасовано додавання обчислення: " + дані.отриматиПараметр1() + " + " + дані.отриматиПараметр2());
    }
}

/**
 * Команда для збереження колекції.
 */
class КомандаЗберегтиКолекцію implements Команда {
    private final ArrayList<ДаніОбчислення> колекція;
    private final String імʼяФайлу;

    /**
     * Конструктор для створення команди збереження.
     * @param колекція Колекція для збереження.
     * @param імʼяФайлу Ім’я файлу для збереження.
     */
    КомандаЗберегтиКолекцію(ArrayList<ДаніОбчислення> колекція, String імʼяФайлу) {
        this.колекція = колекція;
        this.імʼяФайлу = імʼяФайлу;
    }

    public void виконати() {
        ДемонстраціяСеріалізації.зберегтиКолекцію(колекція, імʼяФайлу);
    }

    public void скасувати() {
        System.out.println("Скасування збереження колекції не підтримується");
    }
}

/**
 * Макрокоманда, яка виконує кілька команд послідовно.
 */
class Макрокоманда implements Команда {
    private final ArrayList<Команда> команди;

    /**
     * Конструктор для створення макрокоманди.
     * @param команди Список команд для виконання.
     */
    Макрокоманда(ArrayList<Команда> команди) {
        this.команди = команди;
    }

    public void виконати() {
        for (Команда команда : команди) {
            команда.виконати();
        }
        System.out.println("Макрокоманда виконана");
    }

    public void скасувати() {
        for (int i = команди.size() - 1; i >= 0; i--) {
            команди.get(i).скасувати();
        }
        System.out.println("Макрокоманда скасована");
    }
}

/**
 * Клас-менеджер команд, що використовує шаблон Singleton і Worker Thread.
 */
class МенеджерКоманд {
    private static МенеджерКоманд екземпляр;
    private final BlockingQueue<Команда> чергаКоманд;
    private final Stack<Команда> історіяКоманд;
    private final Thread робочийПотік;

    private МенеджерКоманд() {
        чергаКоманд = new LinkedBlockingQueue<>();
        історіяКоманд = new Stack<>();
        робочийПотік = new Thread(() -> {
            while (true) {
                try {
                    Команда команда = чергаКоманд.take();
                    команда.виконати();
                    історіяКоманд.push(команда);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
        робочийПотік.start();
    }

    /**
     * Повертає єдиний екземпляр менеджера команд.
     * @return Екземпляр МенеджерКоманд.
     */
    static МенеджерКоманд отриматиЕкземпляр() {
        if (екземпляр == null) {
            екземпляр = new МенеджерКоманд();
        }
        return екземпляр;
    }

    /**
     * Додає команду до черги для виконання.
     * @param команда Команда для виконання.
     */
    void виконатиКоманду(Команда команда) {
        try {
            чергаКоманд.put(команда);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * Скасовує останню команду.
     */
    void скасуватиОстаннюКоманду() {
        if (!історіяКоманд.isEmpty()) {
            Команда команда = історіяКоманд.pop();
            команда.скасувати();
        } else {
            System.out.println("Немає команд для скасування");
        }
    }

    /**
     * Зупиняє робочий потік.
     */
    void зупинити() {
        робочийПотік.interrupt();
    }
}

/**
 * Клас для паралельної обробки колекції обчислень.
 */
class ОбробкаКолекції {
    /**
     * Знаходить мінімальний результат у колекції паралельно.
     * @param колекція Колекція обчислень.
     * @return Мінімальний результат.
     */
    static double знайтиМінімум(ArrayList<ДаніОбчислення> колекція) {
        return колекція.parallelStream()
                      .mapToDouble(ДаніОбчислення::отриматиРезультат)
                      .min()
                      .orElse(Double.NaN);
    }

    /**
     * Знаходить максимальний результат у колекції паралельно.
     * @param колекція Колекція обчислень.
     * @return Максимальний результат.
     */
    static double знайтиМаксимум(ArrayList<ДаніОбчислення> колекція) {
        return колекція.parallelStream()
                      .mapToDouble(ДаніОбчислення::отриматиРезультат)
                      .max()
                      .orElse(Double.NaN);
    }

    /**
     * Обчислює середнє значення результатів у колекції паралельно.
     * @param колекція Колекція обчислень.
     * @return Середнє значення результатів.
     */
    static double обчислитиСереднє(ArrayList<ДаніОбчислення> колекція) {
        return колекція.parallelStream()
                      .mapToDouble(ДаніОбчислення::отриматиРезультат)
                      .average()
                      .orElse(Double.NaN);
    }

    /**
     * Відбирає обчислення з результатами, більшими за задане значення, паралельно.
     * @param колекція Колекція обчислень.
     * @param поріг Порогове значення.
     * @return Список відібраних обчислень.
     */
    static ArrayList<ДаніОбчислення> відібратиЗаКритерієм(ArrayList<ДаніОбчислення> колекція, double поріг) {
        return колекція.parallelStream()
                      .filter(дані -> дані.отриматиРезультат() > поріг)
                      .collect(Collectors.toCollection(ArrayList::new));
    }
}

/**
 * Інтерфейс для об’єктів, які можуть відображати результати обчислень.
 */
interface Відображуваний {
    /**
     * Відображає параметри обчислень.
     */
    void відобразитиПараметри();

    /**
     * Відображає результат обчислень.
     */
    void відобразитиРезультат();

    /**
     * Відображає дані у вигляді таблиці з заданою шириною стовпців.
     * @param ширинаСтовпця Ширина стовпців таблиці.
     */
    void відобразитиЯкТаблицю(int ширинаСтовпця);
}

/**
 * Інтерфейс для фабрики, яка створює відображувачі.
 */
interface ФабрикаВідображення {
    /**
     * Створює відображувач для даних.
     * @param дані Дані для відображення.
     * @return Об’єкт, що реалізує Відображуваний.
     */
    Відображуваний створитиВідображувач(ДаніОбчислення дані);
}

/**
 * Клас для текстового відображення параметрів.
 */
class ТекстовийВідображувачПараметри implements Відображуваний {
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення відображувача параметрів.
     * @param дані Дані для відображення.
     */
    ТекстовийВідображувачПараметри(ДаніОбчислення дані) {
        this.дані = дані;
    }

    public void відобразитиПараметри() {
        System.out.println("Параметр 1: " + дані.отриматиПараметр1() + ", Параметр 2: " + дані.отриматиПараметр2());
    }

    public void відобразитиРезультат() {
        System.out.println("Результат (лише параметри): недоступно");
    }

    public void відобразитиЯкТаблицю(int ширинаСтовпця) {
        System.out.println("Відображення параметрів у вигляді таблиці:");
        String заголовок = String.format("|%-" + ширинаСтовпця + "s|%-" + ширинаСтовпця + "s|", "Параметр 1", "Параметр 2");
        String роздільник = "-".repeat(заголовок.length());
        String рядок = String.format("|%-" + ширинаСтовпця + ".2f|%-" + ширинаСтовпця + ".2f|", дані.отриматиПараметр1(), дані.отриматиПараметр2());
        System.out.println(роздільник);
        System.out.println(заголовок);
        System.out.println(роздільник);
        System.out.println(рядок);
        System.out.println(роздільник);
    }
}

/**
 * Клас для текстового відображення результату.
 */
class ТекстовийВідображувачРезультат implements Відображуваний {
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення відображувача результату.
     * @param дані Дані для відображення.
     */
    ТекстовийВідображувачРезультат(ДаніОбчислення дані) {
        this.дані = дані;
    }

    public void відобразитиПараметри() {
        System.out.println("Параметри (лише результат): недоступно");
    }

    public void відобразитиРезультат() {
        System.out.println("Результат: " + дані.отриматиРезультат());
    }

    public void відобразитиЯкТаблицю(int ширинаСтовпця) {
        System.out.println("Відображення результату у вигляді таблиці:");
        String заголовок = String.format("|%-" + ширинаСтовпця + "s|", "Результат");
        String роздільник = "-".repeat(заголовок.length());
        String рядок = String.format("|%-" + ширинаСтовпця + ".2f|", дані.отриматиРезультат());
        System.out.println(роздільник);
        System.out.println(заголовок);
        System.out.println(роздільник);
        System.out.println(рядок);
        System.out.println(роздільник);
    }
}

/**
 * Клас для повного текстового відображення (параметри + результат).
 */
class ТекстовийВідображувачПовний implements Відображуваний {
    private final ДаніОбчислення дані;

    /**
     * Конструктор для створення повного відображувача.
     * @param дані Дані для відображення.
     */
    ТекстовийВідображувачПовний(ДаніОбчислення дані) {
        this.дані = дані;
    }

    public void відобразитиПараметри() {
        System.out.println("Параметр 1: " + дані.отриматиПараметр1() + ", Параметр 2: " + дані.отриматиПараметр2());
    }

    public void відобразитиРезультат() {
        System.out.println("Результат: " + дані.отриматиРезультат());
    }

    public void відобразитиЯкТаблицю(int ширинаСтовпця) {
        System.out.println("Повне відображення у вигляді таблиці:");
        String заголовок = String.format("|%-" + ширинаСтовпця + "s|%-" + ширинаСтовпця + "s|%-" + ширинаСтовпця + "s|", "Параметр 1", "Параметр 2", "Результат");
        String роздільник = "-".repeat(заголовок.length());
        String рядок = String.format("|%-" + ширинаСтовпця + ".2f|%-" + ширинаСтовпця + ".2f|%-" + ширинаСтовпця + ".2f|", 
                                     дані.отриматиПараметр1(), дані.отриматиПараметр2(), дані.отриматиРезультат());
        System.out.println(роздільник);
        System.out.println(заголовок);
        System.out.println(роздільник);
        System.out.println(рядок);
        System.out.println(роздільник);
    }

    /**
     * Перевантажений метод для відображення таблиці з додатковим заголовком.
     * @param ширинаСтовпця Ширина стовпців таблиці.
     * @param заголовокТаблиці Заголовок таблиці.
     */
    public void відобразитиЯкТаблицю(int ширинаСтовпця, String заголовокТаблиці) {
        System.out.println(заголовокТаблиці);
        відобразитиЯкТаблицю(ширинаСтовпця);
    }
}

/**
 * Фабрика для створення відображувача параметрів.
 */
class ФабрикаПараметри implements ФабрикаВідображення {
    public Відображуваний створитиВідображувач(ДаніОбчислення дані) {
        return new ТекстовийВідображувачПараметри(дані);
    }
}

/**
 * Фабрика для створення відображувача результату.
 */
class ФабрикаРезультат implements ФабрикаВідображення {
    public Відображуваний створитиВідображувач(ДаніОбчислення дані) {
        return new ТекстовийВідображувачРезультат(дані);
    }
}

/**
 * Фабрика для створення повного відображувача.
 */
class ФабрикаПовний implements ФабрикаВідображення {
    public Відображуваний створитиВідображувач(ДаніОбчислення дані) {
        return new ТекстовийВідображувачПовний(дані);
    }
}

/**
 * Клас для тестування основної функціональності.
 */
class ТестФункціональності {
    /**
     * Тестує створення відображувачів і відображення даних.
     */
    static void тестуватиВідображення() {
        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        ФабрикаВідображення фабрикаПараметри = new ФабрикаПараметри();
        ФабрикаВідображення фабрикаРезультат = new ФабрикаРезультат();
        ФабрикаВідображення фабрикаПовний = new ФабрикаПовний();

        Відображуваний відображувачПараметри = фабрикаПараметри.створитиВідображувач(калькулятор.отриматиДані());
        Відображуваний відображувачРезультат = фабрикаРезультат.створитиВідображувач(калькулятор.отриматиДані());
        Відображуваний відображувачПовний = фабрикаПовний.створитиВідображувач(калькулятор.отриматиДані());

        відображувачПараметри.відобразитиПараметри();
        відображувачРезультат.відобразитиРезультат();
        відображувачПовний.відобразитиЯкТаблицю(15);
    }

    /**
     * Тестує збереження та завантаження колекції.
     */
    static void тестуватиСеріалізацію() {
        ArrayList<ДаніОбчислення> колекція = new ArrayList<>();
        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        колекція.add(калькулятор.отриматиДані());

        ДемонстраціяСеріалізації.зберегтиКолекцію(колекція, "тест_колекція.ser");
        ArrayList<ДаніОбчислення> завантаженаКолекція = ДемонстраціяСеріалізації.завантажитиКолекцію("тест_колекція.ser");

        if (завантаженаКолекція != null && завантаженаКолекція.size() == 1) {
            ДаніОбчислення дані = завантаженаКолекція.get(0);
            if (Math.abs(дані.отриматиПараметр1() - 5.0) < 0.0001 && Math.abs(дані.отриматиПараметр2() - 3.0) < 0.0001) {
                System.out.println("Тест серіалізації пройдено");
            } else {
                System.out.println("Тест серіалізації не пройдено");
            }
        } else {
            System.out.println("Тест серіалізації не пройдено: колекція не завантажена");
        }
    }

    /**
     * Тестує виконання та скасування команд.
     */
    static void тестуватиКоманди() {
        ArrayList<ДаніОбчислення> колекція = new ArrayList<>();
        Калькулятор калькулятор = new Калькулятор(5.0, 3.0);
        МенеджерКоманд менеджер = МенеджерКоманд.отриматиЕкземпляр();

        Команда командаДодати = new КомандаДодатиОбчислення(колекція, калькулятор.отриматиДані());
        менеджер.виконатиКоманду(командаДодати);

        try {
            Thread.sleep(100); // Чекаємо, щоб Worker Thread обробив команду
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        if (колекція.size() == 1) {
            System.out.println("Тест додавання обчислення пройдено");
        } else {
            System.out.println("Тест додавання обчислення не пройдено");
        }

        менеджер.скасуватиОстаннюКоманду();
        if (колекція.isEmpty()) {
            System.out.println("Тест скасування обчислення пройдено");
        } else {
            System.out.println("Тест скасування обчислення не пройдено");
        }
    }

    /**
     * Тестує виконання макрокоманди.
     */
    static void тестуватиМакрокоманду() {
        ArrayList<ДаніОбчислення> колекція = new ArrayList<>();
        Калькулятор калькулятор1 = new Калькулятор(5.0, 3.0);
        Калькулятор калькулятор2 = new Калькулятор(10.0, 20.0);
        МенеджерКоманд менеджер = МенеджерКоманд.отриматиЕкземпляр();

        ArrayList<Команда> команди = new ArrayList<>();
        команди.add(new КомандаДодатиОбчислення(колекція, калькулятор1.отриматиДані()));
        команди.add(new КомандаДодатиОбчислення(колекція, калькулятор2.отриматиДані()));
        команди.add(new КомандаЗберегтиКолекцію(колекція, "макро_тест.ser"));

        Команда макрокоманда = new Макрокоманда(команди);
        менеджер.виконатиКоманду(макрокоманда);

        try {
            Thread.sleep(100); // Чекаємо, щоб Worker Thread обробив команду
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        if (колекція.size() == 2) {
            System.out.println("Тест макрокоманди пройдено");
        } else {
            System.out.println("Тест макрокоманди не пройдено");
        }

        менеджер.скасуватиОстаннюКоманду();
        if (колекція.isEmpty()) {
            System.out.println("Тест скасування макрокоманди пройдено");
        } else {
            System.out.println("Тест скасування макрокоманди не пройдено");
        }
    }

    /**
     * Тестує паралельну обробку колекції.
     */
    static void тестуватиПаралельнуОбробку() {
        ArrayList<ДаніОбчислення> колекція = new ArrayList<>();
        колекція.add(new Калькулятор(5.0, 3.0).отриматиДані());
        колекція.add(new Калькулятор(10.0, 20.0).отриматиДані());
        колекція.add(new Калькулятор(1.0, 2.0).отриматиДані());

        double мінімум = ОбробкаКолекції.знайтиМінімум(колекція);
        double максимум = ОбробкаКолекції.знайтиМаксимум(колекція);
        double середнє = ОбробкаКолекції.обчислитиСереднє(колекція);
        ArrayList<ДаніОбчислення> відібрані = ОбробкаКолекції.відібратиЗаКритерієм(колекція, 10.0);

        if (мінімум == 3.0 && максимум == 30.0 && Math.abs(середнє - 13.666) < 0.001 && відібрані.size() == 2) {
            System.out.println("Тест паралельної обробки пройдено");
        } else {
            System.out.println("Тест паралельної обробки не пройдено");
        }
    }
}

/**
 * Основний клас програми.
 */
public class Main {
    /**
     * Основний метод програми.
     * @param args Аргументи командного рядка.
     */
    public static void main(String[] args) {
        Scanner сканер = new Scanner(System.in);
        МенеджерКоманд менеджер = МенеджерКоманд.отриматиЕкземпляр();
        ArrayList<ДаніОбчислення> колекціяОбчислень = new ArrayList<>();

        while (true) {
            System.out.println("\nВиберіть дію:");
            System.out.println("1. Додати обчислення");
            System.out.println("2. Зберегти колекцію");
            System.out.println("3. Виконати макрокоманду (додати два обчислення та зберегти)");
            System.out.println("4. Скасувати останню дію");
            System.out.println("5. Відобразити результати");
            System.out.println("6. Обробити колекцію (мін, макс, середнє, відбір)");
            System.out.println("7. Запустити тести");
            System.out.println("8. Вийти");

            int вибір = сканер.nextInt();

            if (вибір == 8) {
                менеджер.зупинити();
                break;
            }

            if (вибір == 1) {
                System.out.println("Введіть перший параметр:");
                double парам1 = сканер.nextDouble();
                System.out.println("Введіть другий параметр:");
                double парам2 = сканер.nextDouble();
                Калькулятор калькулятор = new Калькулятор(парам1, парам2);
                Команда команда = new КомандаДодатиОбчислення(колекціяОбчислень, калькулятор.отриматиДані());
                менеджер.виконатиКоманду(команда);
            } else if (вибір == 2) {
                System.out.println("Введіть ім’я файлу для збереження:");
                String імʼяФайлу = сканер.next();
                Команда команда = new КомандаЗберегтиКолекцію(колекціяОбчислень, імʼяФайлу);
                менеджер.виконатиКоманду(команда);
            } else if (вибір == 3) {
                System.out.println("Введіть перший параметр для першого обчислення:");
                double парам1 = сканер.nextDouble();
                System.out.println("Введіть другий параметр для першого обчислення:");
                double парам2 = сканер.nextDouble();
                System.out.println("Введіть перший параметр для другого обчислення:");
                double парам3 = сканер.nextDouble();
                System.out.println("Введіть другий параметр для другого обчислення:");
                double парам4 = сканер.nextDouble();
                System.out.println("Введіть ім’я файлу для збереження:");
                String імʼяФайлу = сканер.next();

                Калькулятор калькулятор1 = new Калькулятор(парам1, парам2);
                Калькулятор калькулятор2 = new Калькулятор(парам3, парам4);
                ArrayList<Команда> команди = new ArrayList<>();
                команди.add(new КомандаДодатиОбчислення(колекціяОбчислень, калькулятор1.отриматиДані()));
                команди.add(new КомандаДодатиОбчислення(колекціяОбчислень, калькулятор2.отриматиДані()));
                команди.add(new КомандаЗберегтиКолекцію(колекціяОбчислень, імʼяФайлу));
                Команда макрокоманда = new Макрокоманда(команди);
                менеджер.виконатиКоманду(макрокоманда);
            } else if (вибір == 4) {
                менеджер.скасуватиОстаннюКоманду();
            } else if (вибір == 5) {
                if (колекціяОбчислень.isEmpty()) {
                    System.out.println("Колекція порожня");
                    continue;
                }
                System.out.println("Введіть ширину стовпця для таблиці:");
                int ширинаСтовпця = сканер.nextInt();

                ФабрикаВідображення фабрикаПараметри = new ФабрикаПараметри();
                ФабрикаВідображення фабрикаРезультат = new ФабрикаРезультат();
                ФабрикаВідображення фабрикаПовний = new ФабрикаПовний();

                for (ДаніОбчислення дані : колекціяОбчислень) {
                    Відображуваний відображувачПараметри = фабрикаПараметри.створитиВідображувач(дані);
                    Відображуваний відображувачРезультат = фабрикаРезультат.створитиВідображувач(дані);
                    Відображуваний відображувачПовний = фабрикаПовний.створитиВідображувач(дані);

                    відображувачПараметри.відобразитиПараметри();
                    відображувачПараметри.відобразитиРезультат();
                    відображувачПараметри.відобразитиЯкТаблицю(ширинаСтовпця);

                    відображувачРезультат.відобразитиПараметри();
                    відображувачРезультат.відобразитиРезультат();
                    відображувачРезультат.відобразитиЯкТаблицю(ширинаСтовпця);

                    відображувачПовний.відобразитиПараметри();
                    відображувачПовний.відобразитиРезультат();
                    відображувачПовний.відобразитиЯкТаблицю(ширинаСтовпця);
                    ((ТекстовийВідображувачПовний) відображувачПовний).відобразитиЯкТаблицю(ширинаСтовпця, "Повна таблиця обчислень");
                }
            } else if (вибір == 6) {
                if (колекціяОбчислень.isEmpty()) {
                    System.out.println("Колекція порожня");
                    continue;
                }
                System.out.println("Введіть порогове значення для відбору:");
                double поріг = сканер.nextDouble();

                double мінімум = ОбробкаКолекції.знайтиМінімум(колекціяОбчислень);
                double максимум = ОбробкаКолекції.знайтиМаксимум(колекціяОбчислень);
                double середнє = ОбробкаКолекції.обчислитиСереднє(колекціяОбчислень);
                ArrayList<ДаніОбчислення> відібрані = ОбробкаКолекції.відібратиЗаКритерієм(колекціяОбчислень, поріг);

                System.out.println("Мінімальний результат: " + мінімум);
                System.out.println("Максимальний результат: " + максимум);
                System.out.println("Середнє значення: " + середнє);
                System.out.println("Відібрані обчислення (результат > " + поріг + "):");
                for (ДаніОбчислення дані : відібрані) {
                    System.out.println("Параметр 1: " + дані.отриматиПараметр1() + ", Параметр 2: " + дані.отриматиПараметр2() + ", Результат: " + дані.отриматиРезультат());
                }
            } else if (вибір == 7) {
                ТестФункціональності.тестуватиВідображення();
                ТестФункціональності.тестуватиСеріалізацію();
                ТестФункціональності.тестуватиКоманди();
                ТестФункціональності.тестуватиМакрокоманду();
                ТестФункціональності.тестуватиПаралельнуОбробку();
            } else {
                System.out.println("Невірний вибір. Спробуйте ще раз.");
            }
        }

        сканер.close();
    }
}

        сканер.close();
    }
}
